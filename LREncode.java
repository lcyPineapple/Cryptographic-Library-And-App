/** This File contains the methods Left and Right encode.
 * The methods take an integer value from 0 up to 2^2040 - 1
 * and encodes it as a byte array using the following pseudocode from
 * the NIST Specification.
 * 1. Let n be the smallest positive integer for which 2^8n > x.
 * 2. Let x1, x2,…, xn be the base-256 encoding of x satisfying:
 * x = ∑ 28(n-i)
 * xi, for i = 1 to n.
 * 3. Let Oi = enc8(xi), for i = 1 to n.
 * 4. Let On+1 = enc8(n).
 * 5. Return O = O1 || O2 || … || On || On+1
 *
 * @author Leika Yamada
 * @date 4/27/2021
 *
 * */
import java.math.BigInteger;
import java.lang.Math;
public class LREncode {
    /* This method right encodes large integers
    *  into a byte array.
    *  @param x int x, the integer to encode
    *  @return byte[] the byte string generated by the integer
    * */
    public static byte[] right_Encode(int x){
        int n = 1;
        while((1 << 8*n) <= x && n < 256) {
        	n++;
        }
        if (n == 256) {
        	throw new RuntimeException("Integer x in LREncode right_encode is too large");
        }
        byte[] myArr = new byte[n + 1];
        for(int i = 0; i <= n; i++) {
        	myArr[i] = (byte) (x & 0xFF);
        	x = x >>> 8;
        }
        myArr[n + 1] = (byte) n;
        return myArr;
    }
    /* This method right encodes large integers
     *  into a byte array.
     *  @param x int x, the integer to encode
     *  @return byte[] the byte string generated by the integer
     * */
    public static byte[] left_Encode(int x){
    	 int n = 1;
         while((1 << 8*n) <= x && n < 256) {
         	n++;
         }
         if (n == 256) {
         	throw new RuntimeException("Integer x in LREncode left_encode is too large");
         }
         byte[] myArr = new byte[n + 1];
         myArr[0] = (byte) n;
         for(int i = 1; i <= n + 1; i++) {
         	myArr[i] = (byte) (x & 0xFF);
         	x = x >>> 8;
         }
         return myArr;
    }
}

